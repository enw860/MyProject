#lang racket #| Choices and backtracking, Version 3 (UPDATED Mon Mar 5) |#

#| Racket Notes

1.  In the DrRacket menu, go to Language -> Choose Language...
    Click on Show Details, and make sure "Enforce constant definitions"
    is *NOT* checked.
|#
(require racket/control)
(provide -<
         next
         fail
         choices
         generate
         num-between)

; A constant representing the state of having *no more choices*. 
(define done 'done)

; The stack of choice points, represented as a list.
(define choices null)


#|
(-< expr ...)
 expr ... : Any expression.

 Evaluates and returns the first expression, but creates a "choice point"
 that can be returned to later with a different expression used.
|#
(define-syntax -<
  (syntax-rules ()
    ; Given no options, return done.
    [(-<) done]
  
    ; Given one option, return the value.
    [(-< <expr1>) <expr1>]
    
    ; If there are two or more values, return the first one and
    ; store the others in a thunk,
    ; but *also stores the continuation of the -< expression*.
    [(-< <expr1> <expr2> ...)
     (let/cc cont
       ; 1. Store the current continuation and the remaining choices in a thunk.
       (add-choice! (thunk (cont (-< <expr2> ...))))

       ; 2. Evaluate and return the first expression.
       <expr1>)]))


#|
(next)

  Returns the next choice, or `done` if there are no more choices.

  Sample usage (with -<):

  > (+ 10 (-< 1 2 3))
  11
  > (next)
  12
  > (next)
  13
  > (next)
  'done
  > (next)
  'done
|#
(define (next)
  (if (null? choices)
      done
      ; Note the use of `prompt` here, so that calling a saved
      ; choice continuation returns its value from next to
      ; wherever next was called. This enables calling `next`
      ; inside larger expressions, e.g. (+ 10 (next)).
      (prompt ((get-choice!)))))

; NEW (for Lab 8 and Exercise 8)
; Similar to next, except it doesn't wrap the continuation call in a prompt.
; We use this to represent a continuation call that we explicitly want to
; throw away the current execution context, to resume at some previous choice point.
(define (fail)
  (if (null? choices)
      done
      ((get-choice!))))


;-------------------------------------------------------------------------------
; Stack helpers
;-------------------------------------------------------------------------------
; Wrapper functions around the push! and pop! macros.
; This is necessary for exporting purposes, as Racket doesn't allow
; mutation of module identifiers from outside of the module.
; See https://docs.racket-lang.org/guide/module-set.html.
(define (add-choice! c) (push! choices c))
(define (get-choice!) (pop! choices))

(define-syntax push!
  (syntax-rules ()
    [(push! <id> obj)
     (set! <id>
           (cons obj <id>))]))

(define-syntax pop!
  (syntax-rules ()
    [(pop! <id>)
     (let ([obj (first <id>)])
       (set! <id> (rest <id>))
       obj)]))


;-------------------------------------------------------------------------------
; Turning the choices into a stream
;-------------------------------------------------------------------------------
(require "streams.rkt")  ; Download from course website

#|
(all-choices)

  Returns a stream containing the currently-stored choices.
|#
(define (all-choices)
  (let ([val (next)])
    (if (equal? val done)
        s-null
        (s-cons val (all-choices)))))

#|
(generate <expr>)
  <expr>: an expression using the ambiguous operator -<

  Evaluates to a stream containing all choices generated by <expr>.
  Note that this is basically (all-choices), except it captures the
  original expression as well.

  Sample usage:
  > (stream->list (generate (-< 1 2 3)))
  '(1 2 3)
  > (stream->list (generate (+ 10 (-< 1 2 3))))
  '(11 12 13)
  > (stream->list (generate ((-< + *) (-< 2 3 4) (-< 100 200))))
  '(102 202 103 203 104 204 200 400 300 600 400 800)
|#
(define-syntax generate
  (syntax-rules ()
    [(generate <expr>)
     ; Note the use of prompt here. This ensures that the continuation(s)
     ; captured in <expr> don't extend beyond the expression itself.
     (let ([val (prompt <expr>)])
       (if (equal? val 'done)
           s-null
           (s-cons val (all-choices))))]))


;-------------------------------------------------------------------------------
; Useful library functions. (Not core implementation, but utilities.)
;-------------------------------------------------------------------------------
#|
(num-between start end)
  start, end: integers

  Precondition: start <= end

  Returns a choice of a number in the range [start .. end], inclusive.
|#
(define (num-between start end)
  (if (equal? start end)
      (-< end)
      (-< start (num-between (+ 1 start) end))))
